// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: userPokemons.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const getUserAvailablePokemonNames = `-- name: GetUserAvailablePokemonNames :many
SELECT pokemons.name
FROM pokemons
LEFT JOIN user_pokemons
ON user_pokemons.pokemon_id = pokemons.id
WHERE user_id = $1 AND user_pokemons.id IS NULL
`

func (q *Queries) GetUserAvailablePokemonNames(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUserAvailablePokemonNames, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAvailablePokemonsSortedByIdAsc = `-- name: GetUserAvailablePokemonsSortedByIdAsc :many
SELECT pokemons.id, pokemons.name, pokemons.picture_url
FROM pokemons
LEFT JOIN user_pokemons
ON user_pokemons.pokemon_id = pokemons.id
WHERE user_id = $1 AND user_pokemons.id IS NULL
ORDER BY pokemons.id ASC
LIMIT $2 OFFSET $3
`

type GetUserAvailablePokemonsSortedByIdAscParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetUserAvailablePokemonsSortedByIdAscRow struct {
	ID         int32
	Name       string
	PictureUrl string
}

func (q *Queries) GetUserAvailablePokemonsSortedByIdAsc(ctx context.Context, arg GetUserAvailablePokemonsSortedByIdAscParams) ([]GetUserAvailablePokemonsSortedByIdAscRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserAvailablePokemonsSortedByIdAsc, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAvailablePokemonsSortedByIdAscRow
	for rows.Next() {
		var i GetUserAvailablePokemonsSortedByIdAscRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAvailablePokemonsSortedByIdDesc = `-- name: GetUserAvailablePokemonsSortedByIdDesc :many
SELECT pokemons.id, pokemons.name, pokemons.picture_url
FROM pokemons
LEFT JOIN user_pokemons
ON user_pokemons.pokemon_id = pokemons.id
WHERE user_id = $1 AND user_pokemons.id IS NULL
ORDER BY pokemons.id DESC
LIMIT $2 OFFSET $3
`

type GetUserAvailablePokemonsSortedByIdDescParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetUserAvailablePokemonsSortedByIdDescRow struct {
	ID         int32
	Name       string
	PictureUrl string
}

func (q *Queries) GetUserAvailablePokemonsSortedByIdDesc(ctx context.Context, arg GetUserAvailablePokemonsSortedByIdDescParams) ([]GetUserAvailablePokemonsSortedByIdDescRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserAvailablePokemonsSortedByIdDesc, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAvailablePokemonsSortedByIdDescRow
	for rows.Next() {
		var i GetUserAvailablePokemonsSortedByIdDescRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAvailablePokemonsSortedByNameAsc = `-- name: GetUserAvailablePokemonsSortedByNameAsc :many
SELECT pokemons.id, pokemons.name, pokemons.picture_url
FROM pokemons
LEFT JOIN user_pokemons
ON user_pokemons.pokemon_id = pokemons.id
WHERE user_id = $1 AND user_pokemons.id IS NULL
ORDER BY pokemons.name ASC
LIMIT $2 OFFSET $3
`

type GetUserAvailablePokemonsSortedByNameAscParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetUserAvailablePokemonsSortedByNameAscRow struct {
	ID         int32
	Name       string
	PictureUrl string
}

func (q *Queries) GetUserAvailablePokemonsSortedByNameAsc(ctx context.Context, arg GetUserAvailablePokemonsSortedByNameAscParams) ([]GetUserAvailablePokemonsSortedByNameAscRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserAvailablePokemonsSortedByNameAsc, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAvailablePokemonsSortedByNameAscRow
	for rows.Next() {
		var i GetUserAvailablePokemonsSortedByNameAscRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAvailablePokemonsSortedByNameDesc = `-- name: GetUserAvailablePokemonsSortedByNameDesc :many
SELECT pokemons.id, pokemons.name, pokemons.picture_url
FROM pokemons
LEFT JOIN user_pokemons
ON user_pokemons.pokemon_id = pokemons.id
WHERE user_id = $1 AND user_pokemons.id IS NULL
ORDER BY pokemons.name DESC
LIMIT $2 OFFSET $3
`

type GetUserAvailablePokemonsSortedByNameDescParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetUserAvailablePokemonsSortedByNameDescRow struct {
	ID         int32
	Name       string
	PictureUrl string
}

func (q *Queries) GetUserAvailablePokemonsSortedByNameDesc(ctx context.Context, arg GetUserAvailablePokemonsSortedByNameDescParams) ([]GetUserAvailablePokemonsSortedByNameDescRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserAvailablePokemonsSortedByNameDesc, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAvailablePokemonsSortedByNameDescRow
	for rows.Next() {
		var i GetUserAvailablePokemonsSortedByNameDescRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollectedPokemonNames = `-- name: GetUserCollectedPokemonNames :many
SELECT pokemons.name
FROM pokemons
INNER JOIN user_pokemons
ON user_pokemons.pokemon_id = pokemons.id
WHERE user_id = $1
`

func (q *Queries) GetUserCollectedPokemonNames(ctx context.Context, userID uuid.UUID) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollectedPokemonNames, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollectedPokemonsSortedByIdAsc = `-- name: GetUserCollectedPokemonsSortedByIdAsc :many
SELECT pokemons.id, pokemons.name, pokemons.picture_url
FROM pokemons
INNER JOIN user_pokemons
ON user_pokemons.pokemon_id = pokemons.id
WHERE user_id = $1
ORDER BY pokemons.id ASC
LIMIT $2 OFFSET $3
`

type GetUserCollectedPokemonsSortedByIdAscParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetUserCollectedPokemonsSortedByIdAscRow struct {
	ID         int32
	Name       string
	PictureUrl string
}

func (q *Queries) GetUserCollectedPokemonsSortedByIdAsc(ctx context.Context, arg GetUserCollectedPokemonsSortedByIdAscParams) ([]GetUserCollectedPokemonsSortedByIdAscRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollectedPokemonsSortedByIdAsc, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserCollectedPokemonsSortedByIdAscRow
	for rows.Next() {
		var i GetUserCollectedPokemonsSortedByIdAscRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollectedPokemonsSortedByIdDesc = `-- name: GetUserCollectedPokemonsSortedByIdDesc :many
SELECT pokemons.id, pokemons.name, pokemons.picture_url
FROM pokemons
INNER JOIN user_pokemons
ON user_pokemons.pokemon_id = pokemons.id
WHERE user_id = $1
ORDER BY pokemons.id DESC
LIMIT $2 OFFSET $3
`

type GetUserCollectedPokemonsSortedByIdDescParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetUserCollectedPokemonsSortedByIdDescRow struct {
	ID         int32
	Name       string
	PictureUrl string
}

func (q *Queries) GetUserCollectedPokemonsSortedByIdDesc(ctx context.Context, arg GetUserCollectedPokemonsSortedByIdDescParams) ([]GetUserCollectedPokemonsSortedByIdDescRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollectedPokemonsSortedByIdDesc, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserCollectedPokemonsSortedByIdDescRow
	for rows.Next() {
		var i GetUserCollectedPokemonsSortedByIdDescRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollectedPokemonsSortedByNameAsc = `-- name: GetUserCollectedPokemonsSortedByNameAsc :many
SELECT pokemons.id, pokemons.name, pokemons.picture_url
FROM pokemons
INNER JOIN user_pokemons
ON user_pokemons.pokemon_id = pokemons.id
WHERE user_id = $1
ORDER BY pokemons.name ASC
LIMIT $2 OFFSET $3
`

type GetUserCollectedPokemonsSortedByNameAscParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetUserCollectedPokemonsSortedByNameAscRow struct {
	ID         int32
	Name       string
	PictureUrl string
}

func (q *Queries) GetUserCollectedPokemonsSortedByNameAsc(ctx context.Context, arg GetUserCollectedPokemonsSortedByNameAscParams) ([]GetUserCollectedPokemonsSortedByNameAscRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollectedPokemonsSortedByNameAsc, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserCollectedPokemonsSortedByNameAscRow
	for rows.Next() {
		var i GetUserCollectedPokemonsSortedByNameAscRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCollectedPokemonsSortedByNameDesc = `-- name: GetUserCollectedPokemonsSortedByNameDesc :many
SELECT pokemons.id, pokemons.name, pokemons.picture_url
FROM pokemons
INNER JOIN user_pokemons
ON user_pokemons.pokemon_id = pokemons.id
WHERE user_id = $1
ORDER BY pokemons.name DESC
LIMIT $2 OFFSET $3
`

type GetUserCollectedPokemonsSortedByNameDescParams struct {
	UserID uuid.UUID
	Limit  int32
	Offset int32
}

type GetUserCollectedPokemonsSortedByNameDescRow struct {
	ID         int32
	Name       string
	PictureUrl string
}

func (q *Queries) GetUserCollectedPokemonsSortedByNameDesc(ctx context.Context, arg GetUserCollectedPokemonsSortedByNameDescParams) ([]GetUserCollectedPokemonsSortedByNameDescRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserCollectedPokemonsSortedByNameDesc, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserCollectedPokemonsSortedByNameDescRow
	for rows.Next() {
		var i GetUserCollectedPokemonsSortedByNameDescRow
		if err := rows.Scan(&i.ID, &i.Name, &i.PictureUrl); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertUserCollectedPokemon = `-- name: InsertUserCollectedPokemon :exec
INSERT INTO user_pokemons
  (id, user_id, pokemon_id)
VALUES
  ($1, $2, $3)
`

type InsertUserCollectedPokemonParams struct {
	ID        uuid.UUID
	UserID    uuid.UUID
	PokemonID int32
}

func (q *Queries) InsertUserCollectedPokemon(ctx context.Context, arg InsertUserCollectedPokemonParams) error {
	_, err := q.db.ExecContext(ctx, insertUserCollectedPokemon, arg.ID, arg.UserID, arg.PokemonID)
	return err
}
